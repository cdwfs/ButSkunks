Play
════════════════════════════════════════════════════════════════════════

const BLOCK_SIZE = xy(16,16)
const PLAYER_SPAWN_SPRITES = [
    map_tiles_sprite.start_p1,
    map_tiles_sprite.start_p2,
    map_tiles_sprite.start_p3,
    map_tiles_sprite.start_p4,
]
const LEVEL_INFOS = [
    {map: attic_map, floor_sprite:map_tiles_sprite.attic_floor},
    {map: apartment_map, floor_sprite:map_tiles_sprite.apartment_floor},
    {map: basement_map, floor_sprite:map_tiles_sprite.basement_floor},
]

const DIR_S = 0
const DIR_W = 1
const DIR_E = 2
const DIR_N = 3
const OFFSET_FOR_DIR = [xy(0,1), xy(-1,0), xy(1,0), xy(0,-1)]
const ANGLE_FOR_DIR = [-π/2, π, 0, π/2]

def enter_interstitial_mode(data):
    reset_post_effects()
    remove_frame_hooks_by_mode(Play)
    set_mode(Interstitial, level_index) because "Completed level"
def enter_gameover_mode(data):
    reset_post_effects()
    remove_frame_hooks_by_mode(Play)
    set_mode(GameOver) because "Failed to complete level"

const MAX_LEVEL_SECONDS = 60

def map_offset(m):
    const screen_size_in_blocks = SCREEN_SIZE / BLOCK_SIZE
    const map_size_in_blocks = map.size
    return xy(0, 1) * BLOCK_SIZE

def map_pos_to_cell(pos):
    return round(pos / BLOCK_SIZE)

def map_cell_to_pos(cell):
    return BLOCK_SIZE * cell

def at_cell_center(entity):
    // Is this as close as we'll get to the center?
    const distance = |entity.pos - xy(round(entity.pos.x, BLOCK_SIZE.x),round(entity.pos.y, BLOCK_SIZE.y))|
    return max(distance.x, distance.y) < entity.speed

// gets the value of the map cell from a world-space coordinate.
// Only the sign of vel is used, to check the correct direction; its magnitude is ignored.
def map_sprite(pos, vel default xy(0, 0)):
    return get_map_sprite(map, map_pos_to_cell(pos) + sign(vel), 0)
    
def is_cell_empty(pos, vel default xy(0,0)):
    // Check map sprite
    if not map_sprite(pos, vel).can_walk:
        return false
    // TODO: Check for entity in cell
    return true
    
def is_zero(v2):
    return v2.x == 0 and v2.y == 0
def vec_str(v2):
    return "["+v2.x+","+v2.y+"]"

// Version of lerp() where t can be a vector
def vec_lerp(a, b, t):
    return (b - a) * t + a

// Construct an empty array iterable by array[x][y]
def make_array2d(w,h,val default nil):
    let arr = []
    resize(arr, w)
    for x < w:
        let column = []
        for y < h:
            push(column, val)
        arr[x] = column
    return arr
    
def is_dpad_pressed(gamepad):
    // checking just gamepad.x or gamepad.y isn't sufficient; when the opposite direction
    // is pressed, there is one frame where e.g. gamepad.xx is non-zero but gamepad.x is zero
    // TODO: not totally reliable it seems, as quadplay sometimes reports .x, .xx, and .dx as all zero
    // while dpad is in one direction.
    return (gamepad.xx or gamepad.yy) or (gamepad.x or gamepad.y)

def make_skunk_entity(player):
    return make_entity({
        sprite_sheet: player.sprite_sheet,
        sprite: player.sprite_sheet[0][0],
        pos: BLOCK_SIZE * player.spawn_icell,
        gamepad: player.gamepad,
        player: player,
        vel: xy(0,0),
        next_vel: xy(0,0),
        dir: DIR_S,
        speed: 1,
        active_stinkbombs: 0,
        })

// Construct a dummy gamepad object for use by AI players.
def make_dummy_gamepad(player_index):
    return {
        x:0,
        y:0,
        xx:0,
        yy:0,
        a:0,
        b:0,
        aa:0,
        bb:0,
        index:player_index,
        }

// ACTIVE SKUNKS

// Record which cells have active skunks in them
// target: active_skunks
// RO: map, skunk.pos
// RW: skunk_grid
def itor_active_skunk_populate_grid(skunk):
    const icell = map_pos_to_cell(skunk.pos)
    active_skunk_grid[icell.x][icell.y] = skunk

// Determine skunk velocity and facing direction for this frame.
// target: active_skunks
// RO: map, skunk.pos, skunk.gamepad, skunk.speed, skunk.sprite_sheet
// RW: skunk.next_vel, skunk.vel, skunk.dir, skunk.sprite
def itor_active_skunk_update_velocity(skunk):
    // desired behavior:
    // - If we're already moving
    //   - ...and the same direction is already held, keep moving.
    //   - ...and the opposite direction is now held, then change direction instantly.
    //   - ...and an orthogonal direction is now held, then register next_vel and change
    //     direction at the center of the next cell.
    //   - ...and the dpad is released, stop at the center of the next empty cell
    // - If we're not moving, start moving in the desired direction immediately (or just
    //   turn if the path is blocked.
    // - never possible to move in both X and Y simultaneously
    with next_vel, vel, gamepad, speed, dir, sprite, sprite_sheet in skunk:
        // Record desired upcoming turns based on gamepad state
        let sv = sign(vel)
        let sg = sign(xy(gamepad.x, gamepad.y))
        if |sg.x| > ε:
            next_vel = xy(sg.x * speed, 0)
        else if |sg.y| > ε:
            next_vel = xy(0, sg.y * speed)
        
        // TODO: figure out why this causes skunks to fly off through walls. Something
        // about the speed changing mid-game violates some assumptions?
        //speed = if gamepad.b ≠ 0 then 2 else 1
        
        const at_center = at_cell_center(skunk)
        const vel_dir = direction(vel)
        const next_vel_dir = direction(next_vel)
        const next_vel_is_opposite = ‖vel_dir + next_vel_dir‖ < ε
        const next_vel_is_different = ‖vel_dir - next_vel_dir‖ > ε
        if (at_center or next_vel_is_opposite) and next_vel_is_different:
            vel = next_vel
            sv = sign(vel)
        // Determine facing direction
        if      sv.x == -1 and sv.y ==  0: dir = DIR_W
        else if sv.x ==  1 and sv.y ==  0: dir = DIR_E
        else if sv.x ==  0 and sv.y == -1: dir = DIR_N
        else if sv.x ==  0 and sv.y ==  1: dir = DIR_S
        // otherwise, keep current direction
        
        // Stop moving at cell centers if no dpad input
        if at_center and not is_zero(sv) and not is_dpad_pressed(gamepad):
            vel = xy(0,0)
            sv = xy(0,0)
            next_vel = xy(0,0)

// Update the animation for skunk sprites
// target: active_skunks
// RO: skunk.dir, skunk.vel, skunk.sprite_sheet
// RW: skunk.sprite, skunk.angle
def itor_active_skunk_animate(skunk):
    with vel, dir, sprite, sprite_sheet in skunk:
        // Record desired upcoming turns based on gamepad state
        let sv = sign(vel)
        // Choose appropriate animation frame
        const anim = if is_zero(sv) then sprite_sheet.idle else sprite_sheet.walk
        skunk.sprite = anim.frame(mode_frames)
        // Rotate sprite based on direction
        if      dir == DIR_N: skunk.angle = 0°
        else if dir == DIR_W: skunk.angle = 90°
        else if dir == DIR_S: skunk.angle = 180°
        else if dir == DIR_E: skunk.angle = 270°
        

// Apply current velocity to skunk position, taking into account obstacles that block movement.
// target: active_skunks
// RO: bomb_grid, box_grid
// RW: skunk.pos, skunk.vel
def itor_active_skunk_move(skunk):
    const at_center = at_cell_center(skunk)
    with vel, pos in skunk:
        let sv = sign(vel)
        const icell = map_pos_to_cell(pos)
        const fcell = xy((pos.x/BLOCK_SIZE.x) % 1.0, (pos.y/BLOCK_SIZE.y) % 1.0)
        // bombs stop movement halfway into the bomb's cell
        let blocked_by_bomb = false
        // See if the move is possible, but only stop on centers
        if at_center and (not is_cell_empty(pos, vel) or box_grid[icell.x+sv.x][icell.y+sv.y]):
            // Hit wall. Stop moving
            vel = xy(0,0)
            sv = xy(0,0)
        else if blocked_by_bomb:
            // don't move. Don't clear velocity either, which seems risky?
        else:
            // Clear to move
            pos = pos + vel
            // Snap to a pixel on the axis that we're not moving along
            // to prevent error from accumulating
            pos = vec_lerp(round(pos), pos, |sign(vel)|)
        assert(sv.x == 0 || sv.y == 0, "velocity " + vec_str(vel) + " must be all X or all Y")

// Check for player death conditions. If true, move from active_skunks and add to dead_skunks.
// target: active_skunks
// RO: skunk.pos, explosion_grid, mode_frames
// RW: skunk.death_frame, dead_skunks
def itor_active_skunk_kill(skunk):
    const icell = map_pos_to_cell(skunk.pos)
    if explosion_grid[icell.x][icell.y]:
        push(dead_skunks, make_entity({
            pos: skunk.pos,
            sprite: death_sprite[0][0],
            z: skunk.z,
            death_time: mode_frames,
            player: skunk.player,
            }))
        return iterate.REMOVE

// Handle skunks placing stinkbombs.
// target: active_skunks
// RO: skunk.gamepad, skunk.pos, mode_frames
// RW: bomb_grid, skunk.active_bomb_count
def itor_active_skunk_place_stinkbomb(skunk):
    with pos, gamepad, active_stinkbombs in skunk:
        if skunk.active_stinkbombs > 0:
            return
        const icell = map_pos_to_cell(skunk.pos)
        if gamepad.a:
            active_stinkbombs += 1
            const stinkbomb = make_entity({
                pos: map_cell_to_pos(icell),
                scale: xy(0,0),
                opacity: 0,
                sprite: stinkbomb_sprite.outline.frame(0),
                source_skunk: skunk,
                gamepad: skunk.gamepad,
                start_frame: bgm_now_f,
                z:10,
                })
            push(stinkbombs, stinkbomb)

// STINKBOMBS

// Grow stinkbombs until they explode
// target: stinkbombs
// RO:
// RW:
def itor_stinkbomb_grow(stinkbomb):
    with start_frame, scale, opacity, gamepad, sprite in stinkbomb:
        const max_grow_frames = BGM_FRAMES_PER_MEASURE/2
        const size_t = clamp(bgm_now_f - start_frame, 0, max_grow_frames) / max_grow_frames
        sprite = stinkbomb_sprite.outline.frame(mode_frames)
        opacity = 1
        scale = size_t * size_t * xy(1,1)
        if not gamepad.a:
            // stop growing. See whether the bomb succeeded. If so, spawn an explosion of the appropriate
            // size. Either way, destroy the bomb.
            const latency_f = round(AUDIO_LATENCY_FRAMES)
            const target_f = BGM_FRAMES_PER_MEASURE/2 // target frame is halfway through the measure, at the snare hit
            const adjusted_release_measure_f = (bgm_measure_f + BGM_FRAMES_PER_MEASURE - latency_f - target_f) % BGM_FRAMES_PER_MEASURE
            const half_fpm = BGM_FRAMES_PER_MEASURE/2
            const delta_f = if adjusted_release_measure_f > half_fpm then (adjusted_release_measure_f-BGM_FRAMES_PER_MEASURE) else adjusted_release_measure_f
            let bomb_explodes = false
            debug_last_bomb_release_f = adjusted_release_measure_f
            if abs(delta_f) ≤ INPUT_AUDIO_FRAME_TOLERANCE:
                // bomb succeeds! spawn an explosion entity
                bomb_explodes = true
                const explosion = make_entity({
                    pos: stinkbomb.pos,
                    sprite: stinkbomb_sprite.stink.frame(0),
                    start_frame: mode_frames,
                    duration_frames: BGM_FRAMES_PER_MEASURE,
                    start_scale:scale,
                    end_scale:0.75*scale,
                    scale:scale,
                    z:10,
                    })
                push(explosions, explosion)
            else:
                // bomb fizzles.                
            debug_print("raw=" + bgm_measure_f + " adjusted=" + adjusted_release_measure_f + " delta=" + delta_f + (if bomb_explodes then " BOOM" else ""))
            // Help the player by adjusting the latency towards their actual input time.
            if abs(delta_f) < INPUT_AUDIO_FRAME_TOLERANCE/2:
                const old_latency = AUDIO_LATENCY_FRAMES
                AUDIO_LATENCY_FRAMES += (INPUT_LATENCY_CORRECTION_FACTOR * delta_f) % BGM_FRAMES_PER_MEASURE
                debug_print("delta=" + delta_f + ": latency adjusted from " + old_latency + " to " + AUDIO_LATENCY_FRAMES)            
            // Either way, despawn the stinkbomb and let the source skunk drop another one
            stinkbomb.source_skunk.active_stinkbombs -= 1
            return iterate.REMOVE

// EXPLOSIONS

// Record which cells have explosions in them
// target: explosions
// RO: map, explosion.pos, explosion.scale
// RW: explosion_grid
def itor_explosion_populate_grid(explosion):
    const icell = map_pos_to_cell(explosion.pos)
    // explosions above a certain scale affect their neighbor cells
    if explosion.scale.x < ½:
        explosion_grid[icell.x][icell.y] = explosion
    else:
        for dy in [-1,0,1]:
            for dx in [-1,0,1]:
                explosion_grid[icell.x+dx][icell.y+dy] = explosion

// Destroy explosions after a while
// target: explosions
// RO:
// RW:
def itor_explosion_fade(explosion):
    const age_f = mode_frames - explosion.start_frame
    explosion.sprite = stinkbomb_sprite.stink.frame(age_f)
    explosion.opacity = lerp(1, 0.25, smoothstep(0.25, 0.75, (age_f / explosion.duration_frames)))
    explosion.scale = lerp(explosion.start_scale, explosion.end_scale,
        smoothstep(0.0, 1.0, (age_f / explosion.duration_frames)))
    if age_f ≥ explosion.duration_frames:
        return iterate.REMOVE

// BOXES

// Destroy boxes that have been hit by explosions.
// target: boxes
// RO: explosion_grid, box.pos
// RW: boxes, box_grid
def itor_box_break(box):
    const icell = map_pos_to_cell(box.pos)
    if explosion_grid[icell.x][icell.y] ≠ nil:
        box_grid[icell.x][icell.y] = ∅
        return iterate.REMOVE
        
// UI
def draw_ui():
    // Draw countdown timer
    const elapsed_sec = clamp(bgm_now, 0, MAX_LEVEL_SECONDS)
    const remain_sec = MAX_LEVEL_SECONDS - elapsed_sec
    let c = lerp(#f, #f00, smoothstep(0.8, 0.9, elapsed_sec/MAX_LEVEL_SECONDS))
    draw_text({font:font, text:format_number(remain_sec, "  0.00"),
        pos:xy(4,0), y_align:"top", x_align:"left", color:c, scale:1.5})
    // Draw visual aid for explosion timing
    const line_len = 4*BGM_FRAMES_PER_MEASURE
    const line_dx = 48
    const line_end   = xy(4+48, 6)
    const line_start = line_end + xy(line_len, 0)
    const dot_scale_start = xy(3,3)
    const dot_scale_end = xy(9,9)
    const dot_scale_end2 = xy(11,11)
    const angle_start = 0
    const angle_end = 180°
    // main timeline
    draw_line({A:line_start, B:line_end, color:#f, z:0})
    // vertical tick at halfway point
    draw_rect({pos:lerp(line_start, line_end, 0.5), color:#f, size:xy(1,7), z:1})
    // dot before the halfway point
    const offset_measure_t = (bgm_measure_t + 0.5) % 1.0
    draw_rect({pos:lerp(line_start, line_end, 0.5*offset_measure_t), color:#0f0,
        size:dot_scale_start, angle:lerp(angle_start, angle_end, offset_measure_t), z:1})
    // dot after the halfway point, scaling up as it reaches the end
    draw_rect({pos:lerp(line_start, line_end, 0.5+0.5*offset_measure_t), color:#0f0,
        size:lerp(dot_scale_start, dot_scale_end, offset_measure_t),
        angle:lerp(angle_start, angle_end, offset_measure_t), z:1})
    // fading large dot at the end of the timeline
    const col = lerp(#ffff, #0f00, offset_measure_t)
    //const a = (1-offset_measure_t)*(1-offset_measure_t)
    draw_rect({pos:line_end, color:col, size:lerp(dot_scale_end, dot_scale_end2, offset_measure_t),
        angle:lerp(angle_start, angle_end, offset_measure_t), z:2})

// GLOBALS
// The *_grid arrays are 2D arrays. Unless otherwise mentioned, grid[x][y]
// stores a reference to the entity of that type in map cell x,y, or ∅ if
// the cell does not contain an entity of that type.
let map = nil
let map_xform = xy(0,0)
let players = []
let active_skunks = []
let active_skunk_grid = []
let stinkbombs = []
let explosions = []
let explosion_grid = []
let boxes = []
let box_grid = []
let debug_last_bomb_release_f = 0
let level_index = 0

enter(in_level_index)
────────────────────────────────────────────────────────────────────────

// Initialize mode variables
map = nil
map_xform = xy(0,0)
players = []
active_skunks = []
active_skunk_grid = []
stinkbombs = []
explosions = []
explosion_grid = []
boxes = []
box_grid = []
debug_last_bomb_release_f = 0
level_index = in_level_index

// In debug mode, we bypass the main menu and jump straight to play mode.
// Set reasonable defaults.
if size(player_infos) == 0:
    debug_print("Debug mode!")
    player_infos = [{
        gamepad: gamepad_array[0], // includes player index in gamepad.index
        sprite_sheet: skunk_sprite,
    }]
    level_index = 0

let level = LEVEL_INFOS[level_index]
map = deep_clone(level.map)
map_xform = map_offset(map)
    
// Search map for starting cells, so we can look them up by player index
let player_start_icells = []
resize(player_start_icells, size(PLAYER_SPAWN_SPRITES))
for mx < map.size.x:
    for my < map.size.y:
        const icell = xy(mx,my)
        const ms = map[mx][my]
        for p < size(PLAYER_SPAWN_SPRITES):
            if ms == PLAYER_SPAWN_SPRITES[p]:
                player_start_icells[p] = icell
                // overwrite the map cell with a normal floor sprite.
                set_map_sprite(map, icell, level.floor_sprite)

// Search map for box cells, replace them with floors, and spawn box entities
box_grid = make_array2d(map.size.x, map.size.y, ∅)
for mx < map.size.x:
    for my < map.size.y:
        const icell = xy(mx,my)
        const ms = map[mx][my]
        if ms == map_tiles_sprite.block:
            const cell_pos = map_cell_to_pos(icell)
            const box = make_entity({
                sprite: map_tiles_sprite[0][3],
                pos: cell_pos,
                z: 2,
                })
            push(boxes, box)
            box_grid[icell.x][icell.y] = box
            set_map_sprite(map, icell, level.floor_sprite)

// Create players and skunks
for info in player_infos:
    if info == ∅:
        continue
    const player_index = info.gamepad.index
    // store a separate player object, for state that persists across lives
    push(players, {
        lives: 3,
        spawn_icell: player_start_icells[player_index],
        sprite_sheet: info.sprite_sheet,
        gamepad: info.gamepad,
        skunk: nil,
        is_cpu: info.is_cpu or false
        })
for player in players:
    // spawn skunks
    let skunk = make_skunk_entity(player)
    push(active_skunks, skunk)
    player.skunk = skunk
    player.lives -= 1
    
if bgm_is_playing():
    bgm_stop()
let loops = [
    SND_MUSIC_INGAME,
]
bgm_start(loops)

frame
────────────────────────────────────────────────────────────────────────

bgm_update()

// SIMULATE
// Place remaining active skunks in grid
active_skunk_grid = make_array2d(map.size.x, map.size.y, ∅)
iterate(active_skunks, itor_active_skunk_populate_grid)
// Process active skunks
iterate(active_skunks, itor_active_skunk_update_velocity)
iterate(active_skunks, itor_active_skunk_move)
iterate(active_skunks, itor_active_skunk_animate)
// Process stinkbombs and explosions
iterate(explosions, itor_explosion_fade)
explosion_grid = make_array2d(map.size.x, map.size.y, ∅)
iterate(explosions, itor_explosion_populate_grid)
iterate(boxes, itor_box_break)
iterate(stinkbombs, itor_stinkbomb_grow)
iterate(active_skunks, itor_active_skunk_place_stinkbomb)
// Check for level-ending conditions
if size(boxes) == 0:
    // all boxes destroyed; move to next level
    add_frame_hook(fade_out, enter_interstitial_mode, 30, ∅, {})
if bgm_now ≥ MAX_LEVEL_SECONDS:
    add_frame_hook(fade_out, enter_gameover_mode, 30, ∅, {})
    
// DRAW
preserving_transform:
    set_transform(map_xform)
    draw_map({map:map})
    // Offset by ½ a grid square so that we can use integer coordinates for the centers of grid tiles
    compose_transform(0.5 BLOCK_SIZE)
    iterate(active_skunks, draw_entity)
    iterate(stinkbombs, draw_entity)
    iterate(explosions, draw_entity)
    iterate(boxes, draw_entity)
draw_ui()
        
if DEBUG_BGM_OVERLAY:
    bgm_draw_debug()
if DEBUG_BOMB_TIMING:
    preserving_transform:
        reset_transform()
        let tp = xy(SCREEN_SIZE.x-2, 0)
        const half_fpm = BGM_FRAMES_PER_MEASURE/2
        const delta_f = if debug_last_bomb_release_f > half_fpm then (debug_last_bomb_release_f-BGM_FRAMES_PER_MEASURE) else debug_last_bomb_release_f
        const tc = if abs(delta_f) ≤ INPUT_AUDIO_FRAME_TOLERANCE then #8f8 else #f88
        draw_text({text:format_number(delta_f, " 0"), font:font,
            pos:tp, x_align:"right", y_align:"top", color:tc})
        tp.y += font.line_height
        draw_text({text:format_number(AUDIO_LATENCY_FRAMES, " 0"), font:font,
            pos:tp, x_align:"right", y_align:"top", color:#f})
        tp.y += font.line_height
        draw_text({text:format_number(INPUT_AUDIO_FRAME_TOLERANCE, " 0"), font:font,
            pos:tp, x_align:"right", y_align:"top", color:#f})
        tp.y += font.line_height

leave
────────────────────────────────────────────────────────────────────────
