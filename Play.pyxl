Play
════════════════════════════════════════════════════════════════════════

const BLOCK_SIZE = xy(16,16)
const PLAYER_SPAWN_SPRITES = [
    map_tiles_sprite.start_p1,
    map_tiles_sprite.start_p2,
    map_tiles_sprite.start_p3,
    map_tiles_sprite.start_p4,
]
const FLOOR_SPRITE = map_tiles_sprite.floor

const DIR_S = 0
const DIR_W = 1
const DIR_E = 2
const DIR_N = 3
const OFFSET_FOR_DIR = [xy(0,1), xy(-1,0), xy(1,0), xy(0,-1)]
const ANGLE_FOR_DIR = [-π/2, π, 0, π/2]

def enter_postgame_mode(data):
    reset_post_effects()
    remove_frame_hooks_by_mode(Play)
    set_mode(PostGame) because "Game ended"

def map_offset(m):
    const screen_size_in_blocks = SCREEN_SIZE / BLOCK_SIZE
    const map_size_in_blocks = map.size
    return xy(4, 1) * BLOCK_SIZE

def map_pos_to_cell(pos):
    return round(pos / BLOCK_SIZE)

def map_cell_to_pos(cell):
    return BLOCK_SIZE * cell

def at_cell_center(entity):
    // Is this as close as we'll get to the center?
    const distance = |entity.pos - xy(round(entity.pos.x, BLOCK_SIZE.x),round(entity.pos.y, BLOCK_SIZE.y))|
    return max(distance.x, distance.y) < entity.speed

// gets the value of the map cell from a world-space coordinate.
// Only the sign of vel is used, to check the correct direction; its magnitude is ignored.
def map_sprite(pos, vel default xy(0, 0)):
    return get_map_sprite(map, map_pos_to_cell(pos) + sign(vel), 0)
    
def is_cell_empty(pos, vel default xy(0,0)):
    // Check map sprite
    if not map_sprite(pos, vel).can_walk:
        return false
    // TODO: Check for entity in cell
    return true
    
def is_zero(v2):
    return v2.x == 0 and v2.y == 0
def vec_str(v2):
    return "["+v2.x+","+v2.y+"]"

// Version of lerp() where t can be a vector
def vec_lerp(a, b, t):
    return (b - a) * t + a

// Construct an empty array iterable by array[x][y]
def make_array2d(w,h,val default nil):
    let arr = []
    resize(arr, w)
    for x < w:
        let column = []
        for y < h:
            push(column, val)
        arr[x] = column
    return arr
    
def is_dpad_pressed(gamepad):
    // checking just gamepad.x or gamepad.y isn't sufficient; when the opposite direction
    // is pressed, there is one frame where e.g. gamepad.xx is non-zero but gamepad.x is zero
    // TODO: not totally reliable it seems, as quadplay sometimes reports .x, .xx, and .dx as all zero
    // while dpad is in one direction.
    return (gamepad.xx or gamepad.yy) or (gamepad.x or gamepad.y)

def make_skunk_entity(player):
    return make_entity({
        sprite_sheet: player.sprite_sheet,
        sprite: player.sprite_sheet[0][0],
        pos: BLOCK_SIZE * player.spawn_icell,
        gamepad: player.gamepad,
        player: player,
        vel: xy(0,0),
        next_vel: xy(0,0),
        dir: DIR_S,
        speed: 1,
        bomb_range: 1,
        max_active_bomb_count: 1,
        active_bomb_count: 0,
        })

// Construct a dummy gamepad object for use by AI players.
def make_dummy_gamepad(player_index):
    return {
        x:0,
        y:0,
        xx:0,
        yy:0,
        a:0,
        b:0,
        aa:0,
        bb:0,
        index:player_index,
        }

// ACTIVE SKUNKS

// Record which cells have active skunks in them
// target: active_skunks
// RO: map, skunk.pos
// RW: skunk_grid
def itor_active_skunk_populate_grid(skunk):
    const icell = map_pos_to_cell(skunk.pos)
    active_skunk_grid[icell.x][icell.y] = skunk

// Determine skunk velocity and facing direction for this frame.
// target: active_skunks
// RO: map, skunk.pos, skunk.gamepad, skunk.speed, skunk.sprite_sheet
// RW: skunk.next_vel, skunk.vel, skunk.dir, skunk.sprite
def itor_active_skunk_update_velocity(skunk):
    // desired behavior:
    // - If we're already moving
    //   - ...and the same direction is already held, keep moving.
    //   - ...and the opposite direction is now held, then change direction instantly.
    //   - ...and an orthogonal direction is now held, then register next_vel and change
    //     direction at the center of the next cell.
    //   - ...and the dpad is released, stop at the center of the next empty cell
    // - If we're not moving, start moving in the desired direction immediately (or just
    //   turn if the path is blocked.
    // - never possible to move in both X and Y simultaneously
    with next_vel, vel, gamepad, speed, dir, sprite, sprite_sheet in skunk:
        // Record desired upcoming turns based on gamepad state
        let sv = sign(vel)
        let sg = sign(xy(gamepad.x, gamepad.y))
        if |sg.x| > ε:
            next_vel = xy(sg.x * speed, 0)
        else if |sg.y| > ε:
            next_vel = xy(0, sg.y * speed)
        
        // TODO: figure out why this causes skunks to fly off through walls. Something
        // about the speed changing mid-game violates some assumptions?
        //speed = if gamepad.b ≠ 0 then 2 else 1
        
        const at_center = at_cell_center(skunk)
        const vel_dir = direction(vel)
        const next_vel_dir = direction(next_vel)
        const next_vel_is_opposite = ‖vel_dir + next_vel_dir‖ < ε
        const next_vel_is_different = ‖vel_dir - next_vel_dir‖ > ε
        if (at_center or next_vel_is_opposite) and next_vel_is_different:
            vel = next_vel
            sv = sign(vel)
        // Determine facing direction
        if      sv.x == -1 and sv.y ==  0: dir = DIR_W
        else if sv.x ==  1 and sv.y ==  0: dir = DIR_E
        else if sv.x ==  0 and sv.y == -1: dir = DIR_N
        else if sv.x ==  0 and sv.y ==  1: dir = DIR_S
        // otherwise, keep current direction
        
        // Stop moving at cell centers if no dpad input
        if at_center and not is_zero(sv) and not is_dpad_pressed(gamepad):
            vel = xy(0,0)
            sv = xy(0,0)
            next_vel = xy(0,0)

// Update the animation for skunk sprites
// target: active_skunks
// RO: skunk.dir, skunk.vel, skunk.sprite_sheet
// RW: skunk.sprite, skunk.angle
def itor_active_skunk_animate(skunk):
    with vel, dir, sprite, sprite_sheet in skunk:
        // Record desired upcoming turns based on gamepad state
        let sv = sign(vel)
        // Choose appropriate animation frame
        const anim = if is_zero(sv) then sprite_sheet.idle else sprite_sheet.walk
        skunk.sprite = anim.frame(mode_frames)
        // Rotate sprite based on direction
        if      dir == DIR_N: skunk.angle = 0°
        else if dir == DIR_W: skunk.angle = 90°
        else if dir == DIR_S: skunk.angle = 180°
        else if dir == DIR_E: skunk.angle = 270°
        

// Apply current velocity to skunk position, taking into account obstacles that block movement.
// target: active_skunks
// RO: bomb_grid, box_grid
// RW: skunk.pos, skunk.vel
def itor_active_skunk_move(skunk):
    const at_center = at_cell_center(skunk)
    with vel, pos in skunk:
        let sv = sign(vel)
        const icell = map_pos_to_cell(pos)
        const fcell = xy((pos.x/BLOCK_SIZE.x) % 1.0, (pos.y/BLOCK_SIZE.y) % 1.0)
        // bombs stop movement halfway into the bomb's cell
        let blocked_by_bomb = false
        // See if the move is possible, but only stop on centers
        if at_center and (not is_cell_empty(pos, vel) or box_grid[icell.x+sv.x][icell.y+sv.y]):
            // Hit wall. Stop moving
            vel = xy(0,0)
            sv = xy(0,0)
        else if blocked_by_bomb:
            // don't move. Don't clear velocity either, which seems risky?
        else:
            // Clear to move
            pos = pos + vel
            // Snap to a pixel on the axis that we're not moving along
            // to prevent error from accumulating
            pos = vec_lerp(round(pos), pos, |sign(vel)|)
        assert(sv.x == 0 || sv.y == 0, "velocity " + vec_str(vel) + " must be all X or all Y")

// Allow skunks to place bombs
// RO: skunk.gamepad, skunk.pos, mode_frames, skunk.max_active_bomb_count, skunk.bomb_range
// RW: bomb_grid, skunk.active_bomb_count
def itor_active_skunk_place_bomb(skunk):
    // place bombs
    // desired behavior:
    // - bombs are always placed at the center of a cell
    // - can't place a bomb in a cell that already has one
    // - bombs are placed on the player's current cell.
    //   - a player in the cell where a bomb is placed can move OUT of that cell,
    //     but not back in again.
    //   - a player can never move INTO a cell with a bomb.
    //   - if a player is mostly into a new cell, the bomb will be placed in front
    //     of them, such that it can be immediately kicked (or block further movement)
    // - The collision radius for bombs is effectively ½ as large as a full cell.
    //   - This means a player can move partway into a cell with a bomb, and can
    //     be trapped between two bombs in a corridor.
    //   - Does this mean a player could move between bombs in an open space?
    //     - No, orthogonal directional changes are only possible at cell centers. If
    //       a player's forward movement is blocked by a bomb, the only direction they
    //       can move is away (which may be into a cell that's ALSO blocked by a bomb)
    if skunk.active_bomb_count ≥ skunk.max_active_bomb_count:
        return
    const icell = map_pos_to_cell(skunk.pos)
    if skunk.gamepad.aa and is_cell_empty(skunk.pos) and not bomb_grid[icell.x][icell.y]:
        play_sound(SND_BOMB_PLACE)
        const bomb = make_entity({
            sprite: BOMB_SPRITE,
            pos: BLOCK_SIZE*icell,
            scale: xy(1,1),
            z: 2,
            born_frame: mode_frames,
            fuse_frames: 120,
            range: skunk.bomb_range,
            skunk: skunk,
            })
        push(bombs, bomb)
        skunk.active_bomb_count += 1
        bomb_grid[icell.x][icell.y] = bomb

// Check for player death conditions. If true, move from active_skunks and add to dead_skunks.
// target: active_skunks
// RO: skunk.pos, explosion_grid, mode_frames
// RW: skunk.death_frame, dead_skunks
def itor_active_skunk_kill(skunk):
    const icell = map_pos_to_cell(skunk.pos)
    if explosion_grid[icell.x][icell.y]:
        play_sound(SND_skunk_DEATH)
        delay(play_sound, 120, SND_skunk_DEATH2)
        push(dead_skunks, make_entity({
            pos: skunk.pos,
            sprite: death_sprite[0][0],
            z: skunk.z,
            death_time: mode_frames,
            player: skunk.player,
            }))
        return iterate.REMOVE

// BOXES

// GLOBALS
// The *_grid arrays are 2D arrays. Unless otherwise mentioned, grid[x][y]
// stores a reference to the entity of that type in map cell x,y, or ∅ if
// the cell does not contain an entity of that type.
let map = nil
let map_xform = xy(0,0)
let players = []
let active_skunks = []
let active_skunk_grid = []
let boxes = []
let box_grid = []

enter(player_infos)
────────────────────────────────────────────────────────────────────────

// Initialize mode variables
map = deep_clone(template_map)
map_xform = map_offset(map)
players = []
active_skunks = []
active_skunk_grid = []
boxes = []
box_grid = []

if not bgm_is_playing():
    bgm_start()

// In debug mode, we bypass the main menu and jump straight to play mode.
// Set reasonable defaults.
if get_previous_mode() == ∅:
    debug_print("Debug mode!")
    player_infos = [{
        gamepad: gamepad_array[0], // includes player index in gamepad.index
        sprite_sheet: skunk_sprite,
    }]
    
// Search map for starting cells, so we can look them up by player index
let player_start_icells = []
resize(player_start_icells, size(PLAYER_SPAWN_SPRITES))
for mx < map.size.x:
    for my < map.size.y:
        const icell = xy(mx,my)
        const ms = map[mx][my]
        for p < size(PLAYER_SPAWN_SPRITES):
            if ms == PLAYER_SPAWN_SPRITES[p]:
                player_start_icells[p] = icell
                // overwrite the map cell with a normal floor sprite.
                set_map_sprite(map, icell, FLOOR_SPRITE)

// Search map for box cells, replace them with floors, and spawn box entities
box_grid = make_array2d(map.size.x, map.size.y, ∅)
for mx < map.size.x:
    for my < map.size.y:
        const icell = xy(mx,my)
        const ms = map[mx][my]
        if ms == map_tiles_sprite.block:
            const cell_pos = map_cell_to_pos(icell)
            const box = make_entity({
                sprite: map_tiles_sprite[0][3],
                pos: cell_pos,
                z: 2,
                })
            push(boxes, box)
            box_grid[icell.x][icell.y] = box
            set_map_sprite(map, icell, FLOOR_SPRITE)

// Create players and skunks
for info in player_infos:
    if info == ∅:
        continue
    const player_index = info.gamepad.index
    // store a separate player object, for state that persists across lives
    push(players, {
        lives: 3,
        spawn_icell: player_start_icells[player_index],
        sprite_sheet: info.sprite_sheet,
        gamepad: info.gamepad,
        skunk: nil,
        is_cpu: info.is_cpu or false
        })
for player in players:
    // spawn skunks
    let skunk = make_skunk_entity(player)
    push(active_skunks, skunk)
    player.skunk = skunk
    player.lives -= 1

frame
────────────────────────────────────────────────────────────────────────

// SIMULATE
// Place remaining active skunks in grid
active_skunk_grid = make_array2d(map.size.x, map.size.y, ∅)
iterate(active_skunks, itor_active_skunk_populate_grid)
// Process active skunks
iterate(active_skunks, itor_active_skunk_update_velocity)
iterate(active_skunks, itor_active_skunk_move)
iterate(active_skunks, itor_active_skunk_animate)
// DRAW
preserving_transform:
    set_transform(map_xform)
    draw_map({map:map})
    // Offset by ½ a grid square so that we can use integer coordinates for the centers of grid tiles
    compose_transform(0.5 BLOCK_SIZE)
    iterate(active_skunks, draw_entity)
    iterate(boxes, draw_entity)

leave
────────────────────────────────────────────────────────────────────────
