Cutscene
════════════════════════════════════════════════════════════════════════

const CMD_IMAGE = 1
const CMD_TEXT = 2
const CMD_FADE_OUT = 3
const CMD_FADE_IN = 4
const CMD_SOUND = 5
const CMD_WAIT_FOR_INPUT = 6
const CMD_SET_MODE = 7

const MAX_FADE_FRAMES = 6*BGM_FRAMES_PER_MEASURE
// Need a special fade-out function here, since we don't know exactly how many frames
// it will take to reach the target point in the music.
def fade_out_and_enter_game(frames_left, total_frames, data):
    let t = fade_frame_count / MAX_FADE_FRAMES
    let s = smoothstep(1,0,t)
    post_effects.scale = xy(1,1) + s*xy(6,6)
    fade_frame_count = clamp(fade_frame_count-1, 0, MAX_FADE_FRAMES)
    // Change music to transition measure at the beginning of the measure
    if (bgm_measure mod 4) ≤ 2 and not ready_to_enter_game:
        set_volume(bgm_loops[1], 70%)
        ready_to_enter_game = true
    else if ((bgm_measure mod 4) == 0) and bgm_measure_ff and ready_to_enter_game:
        set_mode(Play, data.level_index) because "Started game"

let advance = false
let next_cmd_index = 0
let cmd_start_frame = 0
let image = ∅
let text_args = {}
let post_effects = {}
let intro_timeline = []
let level_index = 0
let fade_frame_count = -1
let ready_to_enter_game = false

enter(in_level_index)
────────────────────────────────────────────────────────────────────────
advance = false
next_cmd_index = 0
cmd_start_frame = 0
image = ∅
text_args = {font:font, text:"", color:#f, pos:xy(0,0), wrap_width:0, text_size:0, z:1, shadow:#0}
post_effects = {}
intro_timeline = []
level_index = in_level_index
fade_frame_count = -1
ready_to_enter_game = false

reset_post_effects()
post_effects = get_post_effects()

// TODO: select timeline based on level_index
intro_timeline = [
    {cmd:CMD_FADE_OUT, color:#0, duration:0},
    {cmd:CMD_IMAGE, image:cutscene1_sprite},
    {cmd:CMD_FADE_IN, color:#0, duration:60},
    {cmd:CMD_TEXT, pos:xy(75,160), color:#f, wrap_width:300, text:"You thought it was nothing.\nUntil they seized your neighborhood.\nIt's time to take it back.", speed:1},
    {cmd:CMD_WAIT_FOR_INPUT, pos:xy(0.5,1.0)*SCREEN_SIZE},
    {cmd:CMD_IMAGE, image:cutscene2_sprite},
    {cmd:CMD_TEXT, pos:xy(75,160), color:#f, wrap_width:300, text:replace("Hold (a) to charge.\nLet go on the beat to blast.\nBreak their stuff to clear the stage.", joy.prompt), speed:1},
    {cmd:CMD_WAIT_FOR_INPUT, pos:xy(0.5,1.0)*SCREEN_SIZE},
    //{cmd:CMD_FADE_OUT, color:#f00, duration:60},
    {cmd:CMD_SET_MODE, mode:1},    
    ]


frame
────────────────────────────────────────────────────────────────────────
bgm_update()
const cmds = intro_timeline
assert(last_value(cmds).cmd == CMD_SET_MODE) // last command must exit this mode

if advance:
    next_cmd_index += 1
    cmd_start_frame = mode_frames
    advance = false
// skip cutscenes with B
if joy.bb:
    play_sound(SND_CURSOR_ACCEPT)
    next_cmd_index = size(cmds)-1

assert(next_cmd_index < size(cmds))
const next_cmd = cmds[next_cmd_index]
// process next command
if next_cmd.cmd == CMD_IMAGE:
    image = next_cmd.image
    advance = true
else if next_cmd.cmd == CMD_FADE_OUT:
    if next_cmd.duration == 0:
        post_effects.color = next_cmd.color
        post_effects.color.a = 1.0
        advance = true
    else:
        const fade_t = (mode_frames - cmd_start_frame) / next_cmd.duration
        post_effects.color = next_cmd.color
        post_effects.color.a = fade_t
        if fade_t ≥ 1.0:
            advance = true
else if next_cmd.cmd == CMD_FADE_IN:
    if next_cmd.duration == 0:
        post_effects.color = next_cmd.color
        post_effects.color.a = 0.0
        advance = true
    else:
        const fade_t = (mode_frames - cmd_start_frame) / next_cmd.duration
        post_effects.color = next_cmd.color
        post_effects.color.a = 1.0 - fade_t
        if fade_t ≥ 1.0:
            advance = true
else if next_cmd.cmd == CMD_TEXT:
    const text_len = size(next_cmd.text)
    if mode_frames == cmd_start_frame:
        text_args.text = next_cmd.text
        text_args.pos = next_cmd.pos
        text_args.color = next_cmd.color
        text_args.wrap_width = next_cmd.wrap_width
        text_args.text_size = 0
    else:
        text_args.text_size += next_cmd.speed
    if any_button_press():
        text_args.text_size = text_len
    if text_args.text_size ≥ text_len:
        advance = true
else if next_cmd.cmd == CMD_WAIT_FOR_INPUT:
    if (floor((mode_frames-cmd_start_frame) / 30) % 2) == 0:
        draw_text({font:font, pos:next_cmd.pos, text:replace("Press (a)", joy.prompt),
            x_align:"right", y_align:"bottom", color:#f, shadow:#0, z:10})
    if any_button_press():
        advance = true
else if next_cmd.cmd == CMD_SET_MODE:
    //set_mode(Play, level_index) because "End of cutscene"
        // we want to fade out until a specific point in the music, which will happen at
    // a specific time (but not necessarily after a specific number of frames).
    // So, the add_frame_hook() here runs "forever", and the hook itself decides
    // when to enter Play mode based on the music playback state
    if fade_frame_count == -1:
        fade_frame_count = MAX_FADE_FRAMES
        add_frame_hook(fade_out_and_enter_game, nil, infinity, get_mode(), {level_index:level_index})

// draw stuff
set_post_effects(post_effects)
if image ≠ ∅:
    draw_sprite({sprite:image.scene.frame(mode_frames), pos:50% SCREEN_SIZE})
draw_text(text_args)
draw_text({font:font, pos:SCREEN_SIZE-xy(8,0), text:replace("(b) Skip", joy.prompt),
    x_align:"right", y_align:"bottom", color:#f, shadow:#0, z:10})

    
leave
────────────────────────────────────────────────────────────────────────
reset_post_effects()
remove_frame_hooks_by_mode(get_mode())
